# RBTree

从根到叶子的最长路径不多于最短路径的两倍长。所以红黑树是大致上是平衡的（不像AVL-tree，要求绝对平衡）。树的插入、删除和查找效率与树的高度成比例，红黑树的高度上限允许在最坏情况下都是高效的，这是红黑树相对于其他二叉搜索树最大的优势。

算法导论对R-B Tree的介绍：
红黑树，一种二叉查找树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。
通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。

红黑树本质上是一种二叉查找树，但它在二叉查找树的基础上额外添加了一个标记（颜色），同时具有一定的规则。这些规则使红黑树保证了一种平衡，插入、删除、查找的最坏时间复杂度都为 O(logn)。

它的统计性能要好于平衡二叉树（AVL树）。

### rb_tree 性质
1. 每个结点要么是红的要么是黑的。  
2. 根结点是黑的。  
3. 每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。  
4. 如果一个结点是红的，那么它的两个儿子都是黑的。  
5. 对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。 

###  tips
1. 特性(3)中的叶子节点，是只为空(NIL或null)的节点。
2. 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。

### 旋转

* 左旋
```
/*
 * 对红黑树的节点(x)进行左旋转
 *
 * 左旋示意图(对节点x进行左旋)：
 *      px                             px
 *     /                              /
 *    x                              y
 *   / \      --(左旋)-->            / \                
 *  lx  y                           x  ry
 *     / \                         / \
 *    ly  ry                      lx  ly
 */
static void rbtree_left_rotate(RBRoot *root, Node *x);
```

* 右旋
```
/*
 * 对红黑树的节点(y)进行右旋转
 *
 * 右旋示意图(对节点y进行左旋)：
 *            py                               py
 *           /                                /
 *          y                                x
 *         /  \      --(右旋)-->            /  \                     
 *        x   ry                           lx   y
 *       / \                                   / \                   
 *      lx  rx                                rx  ry
 */
static void rbtree_right_rotate(RBRoot *root, Node *y);
```

#### rb_tree 插入
将一个节点(z)插入到红黑树中，需要执行哪些步骤呢？首先，将红黑树当作一颗二叉查找树，将节点插入；然后，将节点着色为红色；最后，通过"旋转和重新着色"等一系列操作来修正该树，使之重新成为一颗红黑树。详细描述如下：

第一步: 将红黑树当作一颗二叉查找树，将节点插入。
       红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后它一定还是二叉查找树。这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实。
       好吧？那接下来，我们就来想方设法的旋转以及重新着色，使这颗树重新成为红黑树！

第二步：将插入的节点着色为"红色"。
       为什么着色成红色，而不是黑色呢？为什么呢？在回答之前，我们需要重新温习一下红黑树的特性：
(1) 每个节点或者是黑色，或者是红色。
(2) 根节点是黑色。
(3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]
(4) 如果一个节点是红色的，则它的子节点必须是黑色的。
(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。
       将插入的节点着色为红色，不会违背"特性(5)"！少违背一条特性，就意味着我们需要处理的情况越少。接下来，就要努力的让这棵树满足其它性质即可；满足了的话，它就又是一颗红黑树了。o(∩∩)o...哈哈

第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。
       第二步中，将插入节点着色为"红色"之后，不会违背"特性(5)"。那它到底会违背哪些特性呢？
       对于"特性(1)"，显然不会违背了。因为我们已经将它涂成红色了。
       对于"特性(2)"，显然也不会违背。在第一步中，我们是将红黑树当作二叉查找树，然后执行的插入操作。而根据二叉查找数的特点，插入操作不会改变根节点。所以，根节点仍然是黑色。
       对于"特性(3)"，显然不会违背了。这里的叶子节点是指的空叶子节点，插入非空节点并不会对它们造成影响。
       对于"特性(4)"，是有可能违背的！
那接下来，想办法使之"满足特性(4)"，就可以将树重新构造成红黑树了。

###### 修复插入后的五种情况
* 不需要修复。如果插入的是根结点:
由于原树是空树，此情况只会违反性质2，因此直接把此结点涂为黑色。

* 不需要修复。如果插入的结点的父结点是黑色:
由于此不会违反性质2和性质4，红黑树没有被破坏，所以此时什么也不做。

* 需要修复情况1，如果当前结点的父结点是红色且祖父结点的另一个子结点（叔叔结点）是红色
此时父结点的父结点一定存在，否则插入前就已不是红黑树。与此同时，又分为父结点是祖父结点的左孩子还是右孩子，根据对称性，我们只要解开一个方向就可以了。对此，我们的解决策略是:将当前节点的父节点和叔叔节点涂黑，祖父结点涂红，把当前结点指向祖父节点，从新的当前节点重新开始算法。插入修复情况1转换成了插入修复情况2。

* 需要修复情况2，当前节点的父节点是红色,叔叔节点是黑色，当前节点是其父节点的右子
解决方案:当前节点的父节点做为新的当前节点，以新当前节点为支点左旋。从而插入修复情况2转换成了插入修复情况3。

* 需要修复情况3，当前节点的父节点是红色,叔叔节点是黑色，当前节点是其父节点的左子
解决对策是:父节点变为黑色，祖父节点变为红色，在祖父节点为支点右旋,最后，把根结点涂为黑色，整棵红黑树便重新恢复了平衡。

#### rbtree 的删除操作
第一步：将红黑树当作一颗二叉查找树，将节点删除。
这和"删除常规二叉查找树中删除节点的方法是一样的"。分3种情况：
① 被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就OK了。
② 被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。
③ 被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。在这里，后继节点相当于替身，在将后继节点的内容复制给"被删除节点"之后，再将后继节点删除。这样就巧妙的将问题转换为"删除后继节点"的情况了，下面就考虑后继节点。 在"被删除节点"有两个非空子节点的情况下，它的后继节点不可能是双子非空。既然"的后继节点"不可能双子都非空，就意味着"该节点的后继节点"要么没有儿子，要么只有一个儿子。若没有儿子，则按"情况① "进行处理；若只有一个儿子，则按"情况② "进行处理。
第二步：通过"旋转和重新着色"等一系列来修正该树，使之重新成为一棵红黑树。
因为"第一步"中删除节点之后，可能会违背红黑树的特性。所以需要通过"旋转和重新着色"来修正该树，使之重新成为一棵红黑树。


###### 修复删除后的情况
* 情况1：x的兄弟w是红色的。
对策：改变w、p[z]颜色，再对p[x]做一次左旋，红黑性质得以继续保持。
x的新兄弟new w是旋转之前w的某个孩子，为黑色。
所以，情况1转化成情况2或3、4。

* 情况2：x的兄弟w是黑色的，且w的俩个孩子都是黑色的。
对策：因为w也是黑色的，所以x和w中得去掉一黑色，最后，w变为红。
p[x]为新结点x，赋给x，x<-p[x]。

* 情况3：x的兄弟w是黑色的，w的左孩子是红色，w的右孩子是黑色。
对策：交换w和和其左孩子left[w]的颜色。 即上图的D、C颜色互换。:D。
并对w进行右旋，而红黑性质仍然得以保持。
现在x的新兄弟w是一个有红色右孩子的黑结点，于是将情况3转化为情况4.

* 情况4：x的兄弟w是黑色的，且w的右孩子时红色的。
对策：做颜色修改，并对p[x]做一次旋转，可以去掉x的额外黑色，来把x变成单独的黑色，此举不破坏红黑性质。
将x置为根后，循环结束。
